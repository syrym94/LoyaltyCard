{"version":3,"sources":["../../src/methods/fetchUrl.js"],"names":["defaultsDeep","require","have","getResponseError","module","exports","uri","options","strict","arguments","url","resBodyJson","error","rawResponse","muteErrors","emit","emitter","bind","fetchOptions","headers","redirect","Authorization","credentials","millisecond","authHeader","getAuthHeader","response","fetch","ok","Error","status","statusText","has","get","indexOf","json","e","body","fetchUrl"],"mappings":"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","file":"fetchUrl.js","sourcesContent":["'use strict'\n\nconst defaultsDeep = require('lodash.defaultsdeep')\n\nconst have = require('../have')\nconst getResponseError = require('../getResponseError')\n\nmodule.exports = async function fetchUrl (uri, options = {}) {\n  have.strict(arguments, { url: 'url', options: 'opt Object' })\n\n  let resBodyJson, error\n\n  // Специфические параметры (не передаются в опции fetch)\n  let rawResponse = false\n  let muteErrors = false\n\n  let emit = this.emitter ? this.emitter.emit.bind(this.emitter) : null\n\n  let fetchOptions = defaultsDeep({ ...options }, {\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    redirect: 'manual'\n  })\n\n  if (!fetchOptions.headers.Authorization) {\n    fetchOptions.credentials = 'include'\n  }\n\n  // получаем специфичные параметры\n  if (fetchOptions.rawResponse) {\n    rawResponse = true\n    delete fetchOptions.rawResponse\n  }\n  if (fetchOptions.muteErrors) {\n    muteErrors = true\n    delete fetchOptions.muteErrors\n  }\n  if (fetchOptions.millisecond) {\n    fetchOptions.headers['X-Lognex-Format-Millisecond'] = 'true'\n    delete fetchOptions.millisecond\n  }\n\n  let authHeader = this.getAuthHeader()\n  if (authHeader) {\n    fetchOptions.headers.Authorization = this.getAuthHeader()\n  }\n\n  if (emit) emit('request', { uri, options: fetchOptions })\n\n  /** @type {Response} */\n  let response = await this.fetch(uri, fetchOptions)\n\n  if (emit) emit('response', { uri, options: fetchOptions, response })\n\n  if (rawResponse && muteErrors) return response\n\n  if (!response.ok) {\n    error = new Error(`${response.status} ${response.statusText}`)\n  } else if (rawResponse) {\n    return response\n  }\n\n  // разбираем тело запроса\n  if (\n    response.headers.has('Content-Type') &&\n    response.headers.get('Content-Type').indexOf('application/json') !== -1\n  ) {\n    // response.json() может вызвать ошибку, если тело ответа пустое\n    try {\n      resBodyJson = await response.json()\n    } catch (e) {}\n\n    if (emit) emit('response:body', { uri, options: fetchOptions, response, body: resBodyJson })\n    error = getResponseError(resBodyJson) || error\n  }\n\n  if (error && !muteErrors) {\n    if (emit) emit('error', error)\n    throw error\n  }\n\n  return rawResponse ? response : resBodyJson\n}\n"]}