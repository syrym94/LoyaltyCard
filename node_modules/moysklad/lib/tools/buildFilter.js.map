{"version":3,"sources":["../../src/tools/buildFilter.js"],"names":["getTimeString","require","isPlainObject","isSimpleValue","createValueSelector","selector","path","value","TypeError","createCollectionSelector","sel","Array","reduce","res","v","concat","selectors","eq","operator","gt","gte","lt","lte","ne","contains","st","et","in","collection","nin","Object","keys","forEach","key","name","not","comparisonSelectors","op","invertFilterPart","fp","Error","getFilterParts","pathLen","length","curKey","val","slice","headPath","map","parts","error","message","module","exports","buildFilter","filter","filterParts","part","join","undefined","Date","sort","p1","p2"],"mappings":"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","file":"buildFilter.js","sourcesContent":["'use strict'\n\nconst getTimeString = require('./getTimeString')\nconst isPlainObject = require('./isPlainObject')\nconst isSimpleValue = require('./isSimpleValue')\n\nlet createValueSelector = selector => (path, value) => {\n  if (!isSimpleValue(value)) {\n    throw new TypeError(`value must to be string, number, date or null`)\n  }\n  return [[path, selector, value]]\n}\n\nlet createCollectionSelector = selector => {\n  const sel = createValueSelector(selector)\n  return (path, value) => {\n    if (!(value instanceof Array)) {\n      throw new TypeError(`selector value must to be an array`)\n    }\n    return value.reduce((res, v) => res.concat(sel(path, v)), [])\n  }\n}\n\n// Comparison selectors\nconst selectors = {\n  eq: { operator: '=' },\n  gt: { operator: '>' },\n  gte: { operator: '>=' },\n  lt: { operator: '<' },\n  lte: { operator: '<=' },\n  ne: { operator: '!=' },\n  contains: { operator: '~' },\n  st: { operator: '~=' },\n  et: { operator: '=~' },\n  in: { operator: '=', collection: true },\n  nin: { operator: '!=', collection: true }\n}\n\nObject.keys(selectors).forEach(key => {\n  selectors[key].name = `$${key}`\n})\n\nselectors.eq.not = selectors.ne\nselectors.gt.not = selectors.lte\nselectors.gte.not = selectors.lt\nselectors.lt.not = selectors.gte\nselectors.lte.not = selectors.gt\nselectors.ne.not = selectors.eq\nselectors.in.not = selectors.nin\nselectors.nin.not = selectors.in\n\nconst comparisonSelectors = Object.keys(selectors).reduce((res, key) => {\n  let op = selectors[key]\n  res['$' + key] = (op.collection ? createCollectionSelector : createValueSelector)(op)\n  return res\n}, {})\n\n// Logical selectors\nconst invertFilterPart = fp => {\n  if (!fp[1].not) {\n    throw new Error(`${fp[1].name} not support negation like $not`)\n  }\n  return [fp[0], fp[1].not, fp[2]]\n}\n\nfunction getFilterParts (path, value) {\n  const pathLen = path.length\n  const curKey = pathLen ? path[pathLen - 1] : null\n\n  switch (true) {\n    // Mongo logical selectors\n    case curKey === '$and':\n      if (!(value instanceof Array)) {\n        throw new TypeError(`$and: selector value must to be an array`)\n      }\n      return value.reduce((res, val) => res\n        .concat(getFilterParts(path.slice(0, -1), val)), [])\n\n    case curKey === '$not':\n      if (!isPlainObject(value)) {\n        throw new TypeError(`$not: selector value must to be an object`)\n      }\n      let headPath = path.slice(0, -1)\n      return getFilterParts(headPath, value)\n        .map(invertFilterPart)\n        // .concat([[headPath, selectors.eq, null]])\n\n    case curKey === '$exists':\n      if (typeof value !== 'boolean') {\n        throw new TypeError(`$exists: selector value must to be boolean`)\n      }\n      return [[path.slice(0, -1), value ? selectors.ne : selectors.eq, null]]\n\n    // Mongo comparison selectors\n    case !!comparisonSelectors[curKey]:\n      let parts\n      try {\n        parts = comparisonSelectors[curKey](path.slice(0, -1), value)\n      } catch (error) {\n        throw new Error(`${curKey}: ${error.message}`)\n      }\n      return parts\n\n    // Array\n    case value instanceof Array:\n      return value.reduce((res, val) => res\n        .concat(getFilterParts(path, val)), [])\n\n    // Object\n    case !isSimpleValue(value):\n      return Object.keys(value).reduce((res, key) => res\n        .concat(getFilterParts(path.concat(key), value[key])), [])\n\n    // some other value\n    default:\n      return [[path, selectors.eq, value]]\n  }\n}\n\nmodule.exports = function buildFilter (filter) {\n  if (!isPlainObject(filter)) {\n    throw new TypeError('filter must to be an object')\n  }\n\n  let filterParts = getFilterParts([], filter)\n\n  // преобразование ключа в строку\n  filterParts = filterParts.map(part => [part[0].join('.'), part[1], part[2]])\n\n  return filterParts\n    // конвертация операторов и значений в строку\n    .map(part => {\n      let key = part[0]\n      let operator = part[1].operator\n      let value = part[2]\n      switch (true) {\n        case value === undefined:\n          throw new TypeError(`filter \"${key}\" key value is undefined`)\n\n        case value === null:\n          return [key, operator, '']\n\n        case value instanceof Date:\n          return [key, operator, getTimeString(value)]\n\n        case typeof value === 'string':\n        case typeof value === 'number':\n        case typeof value === 'boolean':\n          return [key, operator, value]\n\n        default:\n          throw new TypeError(`filter \"${key}\" key value is incorrect`)\n      }\n    })\n    .map(part => `${part[0]}${part[1]}${part[2]}`)\n    .sort((p1, p2) => {\n      if (p1 > p2) { return 1 }\n      if (p1 < p2) { return -1 }\n      return 0\n    })\n    .join(';')\n}\n"]}