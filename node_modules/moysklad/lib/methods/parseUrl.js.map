{"version":3,"sources":["../../src/methods/parseUrl.js"],"names":["have","require","normalizeUrl","parseQueryString","PATH_QUERY_REGEX","module","exports","parseUrl","args","strict","arguments","url","path","getOptions","endpoint","api","apiVersion","Array","join","split","query","pathAndQuery","baseUrl","indexOf","Error","substring","length","exec","pathStr","queryStr"],"mappings":";AAAA;;;;AAEA,MAAMA,OAAOC,QAAQ,SAAR,CAAb;AACA,MAAMC,eAAeD,QAAQ,uBAAR,CAArB;AACA,MAAME,mBAAmBF,QAAQ,2BAAR,CAAzB;;AAEA,MAAMG,mBAAmB,qBAAzB;;AAEAC,OAAOC,OAAP,GAAiB,SAASC,QAAT,GAA4B;AAAA,oCAANC,IAAM;AAANA,QAAM;AAAA;;AAAA,qBACvBR,KAAKS,MAAL,CAAYC,SAAZ,EAAuB,CACzC,EAAEC,KAAK,KAAP,EADyC,EAEzC,EAAEC,MAAM,gBAAR,EAFyC,CAAvB,CADuB;;AAAA,MACrCD,GADqC,gBACrCA,GADqC;AAAA,MAChCC,IADgC,gBAChCA,IADgC;;AAAA,oBAMP,KAAKC,UAAL,EANO;;AAAA,MAMrCC,QANqC,eAMrCA,QANqC;AAAA,MAM3BC,GAN2B,eAM3BA,GAN2B;AAAA,MAMtBC,UANsB,eAMtBA,UANsB;;;AAQ3C,MAAIJ,gBAAgBK,KAApB,EAA2B;AACzB,WAAO;AACLH,wBADK;AAELC,cAFK;AAGLC,4BAHK;AAILJ,YAAMV,aAAaU,KAAKM,IAAL,CAAU,GAAV,CAAb,EAA6BC,KAA7B,CAAmC,KAAnC,CAJD;AAKLC,aAAO;AALF,KAAP;AAOD;;AAED,MAAIC,YAAJ;;AAEA,MAAIV,GAAJ,EAAS;AACP,QAAIW,UAAUpB,aAAa,CAACY,QAAD,EAAWC,GAAX,EAAgBC,UAAhB,EAA4BE,IAA5B,CAAiC,GAAjC,CAAb,CAAd;AACA,QAAIP,IAAIY,OAAJ,CAAYD,OAAZ,MAAyB,CAA7B,EAAgC;AAC9B,YAAM,IAAIE,KAAJ,CAAU,+DAA+DF,OAAzE,CAAN;AACD;AACDD,mBAAeV,IAAIc,SAAJ,CAAcH,QAAQI,MAAR,GAAiB,CAA/B,CAAf;AACD,GAND,MAMO;AACLL,mBAAeT,IAAf;AACD;;AA5B0C,8BA8BfR,iBAAiBuB,IAAjB,CAAsBN,YAAtB,CA9Be;AAAA;;AAAA,MA8BpCO,OA9BoC;AAAA,MA8B3BC,QA9B2B;;;AAgC3C,MAAI,CAACD,OAAL,EAAc,MAAM,IAAIJ,KAAJ,CAAU,wBAAV,CAAN;;AAEd;;AAEA,SAAO;AACLV,sBADK;AAELC,YAFK;AAGLC,0BAHK;AAILJ,UAAMV,aAAa0B,OAAb,EAAsBT,KAAtB,CAA4B,KAA5B,CAJD;AAKLC,WAAOjB,iBAAiB0B,QAAjB,KAA8B;AALhC,GAAP;AAOD,CA3CD","file":"parseUrl.js","sourcesContent":["'use srict'\n\nconst have = require('../have')\nconst normalizeUrl = require('../tools/normalizeUrl')\nconst parseQueryString = require('../tools/parseQueryString')\n\nconst PATH_QUERY_REGEX = /([^?]+)(?:\\?(.+))?$/\n\nmodule.exports = function parseUrl (...args) {\n  let { url, path } = have.strict(arguments, [\n    { url: 'url' },\n    { path: 'str or str arr' }\n  ])\n\n  let { endpoint, api, apiVersion } = this.getOptions()\n\n  if (path instanceof Array) {\n    return {\n      endpoint,\n      api,\n      apiVersion,\n      path: normalizeUrl(path.join('/')).split(/\\//g),\n      query: {}\n    }\n  }\n\n  let pathAndQuery\n\n  if (url) {\n    let baseUrl = normalizeUrl([endpoint, api, apiVersion].join('/'))\n    if (url.indexOf(baseUrl) !== 0) {\n      throw new Error('Url не соответствует указанной в настройках точке доступа ' + baseUrl)\n    }\n    pathAndQuery = url.substring(baseUrl.length + 1)\n  } else {\n    pathAndQuery = path\n  }\n\n  let [, pathStr, queryStr] = PATH_QUERY_REGEX.exec(pathAndQuery)\n\n  if (!pathStr) throw new Error('Не указан путь запроса')\n\n  // TODO Parse query.filter\n\n  return {\n    endpoint,\n    api,\n    apiVersion,\n    path: normalizeUrl(pathStr).split(/\\//g),\n    query: parseQueryString(queryStr) || {}\n  }\n}\n"]}